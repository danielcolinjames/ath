"use strict";
const fs_1 = require("fs");
const os_1 = require("os");
const path_1 = require("path");
const tar_fs_1 = require("tar-fs");
const zlib_1 = require("zlib");
class LambdaFS {
    /**
     * Lazy loads the appropriate Brotli decompression package.
     * On Node 10.16+ it's provided natively by the `zlib` module.
     * On Node 8.10 runtime (under AWS Lambda) a compatible `iltorb` package is provided.
     */
    static get brotli() {
        if (zlib_1.createBrotliDecompress !== undefined) {
            return zlib_1.createBrotliDecompress;
        }
        if (this.hasOwnProperty('_brotli') !== true) {
            let iltorb = 'iltorb';
            if (process.env.AWS_EXECUTION_ENV === 'AWS_Lambda_nodejs8.10') {
                iltorb = path_1.join(__dirname, 'iltorb');
            }
            try {
                this._brotli = require(iltorb).decompressStream;
            }
            catch (error) {
                if (error.code === 'MODULE_NOT_FOUND') {
                    throw new Error(`Failed to load 'iltorb' package.`);
                }
                throw error;
            }
        }
        return this._brotli;
    }
    /**
     * Compreses a file/folder with Gzip and returns the path to the compressed (tarballed) file.
     *
     * @param path Path of the file/folder to compress.
     */
    static deflate(path) {
        let output = path_1.join(os_1.tmpdir(), [path_1.basename(path), fs_1.statSync(path).isDirectory() ? 'tar.gz' : 'gz'].join('.'));
        return new Promise((resolve, reject) => {
            let source = output.endsWith('.tar.gz') ? tar_fs_1.pack(path) : fs_1.createReadStream(path, { highWaterMark: 2 ** 23 });
            let target = fs_1.createWriteStream(output, { mode: 0o644 });
            source.once('error', (error) => {
                return reject(error);
            });
            target.once('error', (error) => {
                return reject(error);
            });
            target.once('close', () => {
                return resolve(output);
            });
            source.pipe(zlib_1.createGzip({ chunkSize: 2 ** 21 })).pipe(target);
        });
    }
    /**
     * Decompresses a (tarballed) Brotli or Gzip compressed file and returns the path to the decompressed file/folder.
     *
     * @param path Path of the file to decompress.
     */
    static inflate(path) {
        let output = path_1.join(os_1.tmpdir(), path_1.basename(path).replace(/[.](?:t(?:ar(?:[.](?:br|gz))?|br|gz)|br|gz)$/i, ''));
        return new Promise((resolve, reject) => {
            if (fs_1.existsSync(output) === true) {
                return resolve(output);
            }
            let source = fs_1.createReadStream(path, { highWaterMark: 2 ** 23 });
            let target = null;
            if (/[.](?:t(?:ar(?:[.](?:br|gz))?|br|gz))$/i.test(path) === true) {
                target = tar_fs_1.extract(output);
                target.once('finish', () => {
                    return resolve(output);
                });
            }
            else {
                target = fs_1.createWriteStream(output, { mode: 0o700 });
            }
            source.once('error', (error) => {
                return reject(error);
            });
            target.once('error', (error) => {
                return reject(error);
            });
            target.once('close', () => {
                return resolve(output);
            });
            if (/(?:br|gz)$/i.test(path) === true) {
                source.pipe(/br$/i.test(path) ? LambdaFS.brotli({ chunkSize: 2 ** 21 }) : zlib_1.createUnzip({ chunkSize: 2 ** 21 })).pipe(target);
            }
            else {
                source.pipe(target);
            }
        });
    }
}
module.exports = LambdaFS;
//# sourceMappingURL=index.js.map